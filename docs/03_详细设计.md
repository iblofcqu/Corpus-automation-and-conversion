# PDF文本提取后台服务 - 详细设计文档

**文档版本**: v1.0
**编写日期**: 2026年1月20日
**项目名称**: PDF文本提取与本体论分析后台服务

---

## 1. 数据库设计

### 1.1 数据库选型

- **数据库**: PostgreSQL 14+
- **ORM**: Django ORM
- **迁移工具**: Django Migrations
- **字符集**: UTF-8

### 1.2 ER图

```
┌─────────────────────┐
│    Django User      │  (使用django.contrib.auth.models.User)
├─────────────────────┤
│ id (PK)             │
│ username (UNIQUE)   │──┐  (存储来自Header的X-User-ID)
│ email               │  │
│ date_joined         │  │
│ ... (Django字段)    │  │
└─────────────────────┘  │
                         │
                         │  1:N
                         │
                         ▼
          ┌─────────────────────────┐
          │       Project           │
          ├─────────────────────────┤
          │ id (PK)                 │──┐
          │ name                    │  │
          │ description (NULL)      │  │
          │ ontology_path           │  │
          │ is_deleted              │  │
          │ created_by (FK→User)    │  │
          │ created_at              │  │
          │ updated_at              │  │
          └─────────────────────────┘  │
                                       │  1:N
                                       │
                                       ▼
                      ┌─────────────────────────────┐
                      │         File                │
                      ├─────────────────────────────┤
                      │ id (PK)                     │
                      │ project_id (FK→Project)     │
                      │ filename                    │
                      │ original_name               │
                      │ pdf_path                    │
                      │ status (ENUM)               │
                      │ mineru_output_path (NULL)   │
                      │ extraction_output_path(NULL)│
                      │ error_message (NULL)        │
                      │ task_id (NULL)              │
                      │ created_by (FK→User)        │
                      │ uploaded_at                 │
                      │ processed_at (NULL)         │
                      └─────────────────────────────┘
```

### 1.3 表结构详细设计

#### 1.3.1 User表

**使用Django内置User模型** (`django.contrib.auth.models.User`)

| 字段名      | 数据类型     | 约束             | 说明                    |
| ----------- | ------------ | ---------------- | ----------------------- |
| id          | INTEGER      | PRIMARY KEY      | 自增主键                |
| username    | VARCHAR(150) | UNIQUE, NOT NULL | 用户名（存储X-User-ID） |
| email       | VARCHAR(254) | NULL             | 邮箱（可选）            |
| first_name  | VARCHAR(150) | NULL             | 名字（可选）            |
| last_name   | VARCHAR(150) | NULL             | 姓氏（可选）            |
| is_active   | BOOLEAN      | DEFAULT TRUE     | 是否激活                |
| date_joined | TIMESTAMP    | NOT NULL         | 加入时间                |
| ...         | ...          | ...              | 其他Django字段          |

**说明**:

- 复用Django内置的User模型，表名为 `auth_user`
- username字段存储来自Nginx Header的X-User-ID
- 首次访问时通过 `User.objects.get_or_create(username=user_id)`自动创建
- password字段不使用（设置为不可用密码）
- 可通过Django Admin管理用户

#### 1.3.2 Project表

| 字段名        | 数据类型     | 约束                           | 说明               |
| ------------- | ------------ | ------------------------------ | ------------------ |
| id            | SERIAL       | PRIMARY KEY                    | 自增主键           |
| name          | VARCHAR(255) | NOT NULL                       | 项目名称           |
| description   | TEXT         | NULL                           | 项目描述           |
| ontology_path | VARCHAR(500) | NOT NULL                       | 本体论文件相对路径 |
| is_deleted    | BOOLEAN      | NOT NULL, DEFAULT FALSE        | 软删除标记         |
| created_by    | INTEGER      | FOREIGN KEY(User.id), NOT NULL | 创建者             |
| created_at    | TIMESTAMP    | NOT NULL, DEFAULT NOW()        | 创建时间           |
| updated_at    | TIMESTAMP    | NOT NULL, DEFAULT NOW()        | 更新时间           |

**索引**:

- `idx_project_created_by` ON created_by
- `idx_project_is_deleted` ON is_deleted
- `idx_project_created_at` ON created_at DESC

**外键约束**:

- created_by REFERENCES auth_user(id) ON DELETE CASCADE

**说明**:

- ontology_path默认值: "ontology/ontology_v2.json"
- is_deleted=True时不在列表中显示
- 物理文件不删除

#### 1.3.3 File表

| 字段名                 | 数据类型     | 约束                              | 说明                    |
| ---------------------- | ------------ | --------------------------------- | ----------------------- |
| id                     | SERIAL       | PRIMARY KEY                       | 自增主键                |
| project_id             | INTEGER      | FOREIGN KEY(Project.id), NOT NULL | 所属项目                |
| filename               | VARCHAR(255) | NOT NULL                          | 存储文件名(UUID_原始名) |
| original_name          | VARCHAR(255) | NOT NULL                          | 原始文件名              |
| pdf_path               | VARCHAR(500) | NOT NULL                          | PDF文件相对路径         |
| status                 | VARCHAR(20)  | NOT NULL, DEFAULT 'pending'       | 处理状态                |
| mineru_output_path     | VARCHAR(500) | NULL                              | MinerU输出路径          |
| extraction_output_path | VARCHAR(500) | NULL                              | 本体论提取输出路径      |
| error_message          | TEXT         | NULL                              | 错误信息                |
| task_id                | VARCHAR(255) | NULL                              | Celery任务ID            |
| created_by             | INTEGER      | FOREIGN KEY(User.id), NOT NULL    | 上传者                  |
| uploaded_at            | TIMESTAMP    | NOT NULL, DEFAULT NOW()           | 上传时间                |
| processed_at           | TIMESTAMP    | NULL                              | 处理完成时间            |

**枚举类型 - status**:

- `pending`: 等待处理
- `processing`: 处理中
- `completed`: 处理完成
- `failed`: 处理失败

**索引**:

- `idx_file_project_id` ON project_id
- `idx_file_status` ON status
- `idx_file_task_id` ON task_id
- `idx_file_uploaded_at` ON uploaded_at DESC
- `idx_file_project_uploaded` ON (project_id, uploaded_at DESC) (复合索引，优化分页查询)

**外键约束**:

- project_id REFERENCES Project(id) ON DELETE CASCADE
- created_by REFERENCES auth_user(id) ON DELETE CASCADE

**说明**:

- pdf_path示例: "pdf/1/uuid_filename.pdf"
- mineru_output_path示例: "mineru/1/uuid_filename/"
- extraction_output_path示例: "extraction/1/uuid_filename/"
- 所有路径都是相对于MEDIA_ROOT的相对路径

### 1.4 Django Models代码骨架

```python
# 无需自定义User模型，直接使用Django内置User
# from django.contrib.auth.models import User

# apps/projects/models.py
from django.db import models
from django.contrib.auth.models import User

class Project(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    ontology_path = models.CharField(
        max_length=500,
        default='ontology/ontology_v2.json'
    )
    is_deleted = models.BooleanField(default=False, db_index=True)
    created_by = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='projects'
    )
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)
  
    class Meta:
        db_table = 'projects'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['created_by', 'is_deleted']),
        ]
  
    def __str__(self):
        return self.name

# apps/files/models.py
from django.db import models
from django.contrib.auth.models import User
from apps.projects.models import Project

class File(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    ]
  
    project = models.ForeignKey(
        Project,
        on_delete=models.CASCADE,
        related_name='files'
    )
    filename = models.CharField(max_length=255)
    original_name = models.CharField(max_length=255)
    pdf_path = models.CharField(max_length=500)
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending',
        db_index=True
    )
    mineru_output_path = models.CharField(max_length=500, null=True, blank=True)
    extraction_output_path = models.CharField(max_length=500, null=True, blank=True)
    error_message = models.TextField(null=True, blank=True)
    task_id = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    created_by = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='uploaded_files'
    )
    uploaded_at = models.DateTimeField(auto_now_add=True, db_index=True)
    processed_at = models.DateTimeField(null=True, blank=True)
  
    class Meta:
        db_table = 'files'
        ordering = ['-uploaded_at']
        indexes = [
            models.Index(fields=['project', '-uploaded_at']),
        ]
  
    def __str__(self):
        return f"{self.original_name} ({self.status})"
```

---

## 2. API接口详细设计

### 2.1 统一响应格式

#### 2.1.1 成功响应

```json
{
  "status": 200,
  "message": "",
  "data": {
    // 实际数据内容
  }
}
```

#### 2.1.2 错误响应

```json
{
  "status": 400,  // 或其他HTTP状态码
  "message": "详细错误描述",
  "data": null
}
```

#### 2.1.3 分页响应

```json
{
  "status": 200,
  "message": "",
  "data": {
    "count": 100,      // 总记录数
    "page": 1,         // 当前页码
    "page_size": 10,   // 每页数量
    "results": [       // 数据列表
      {...},
      {...}
    ]
  }
}
```

### 2.2 项目管理API

#### 2.2.1 创建项目

**端点**: `POST /api/v1/projects/`

**请求头**:

```
Content-Type: multipart/form-data
X-User-ID: user123
```

**请求参数**:

| 参数名        | 类型   | 必需 | 说明                  |
| ------------- | ------ | ---- | --------------------- |
| name          | string | 是   | 项目名称，最大255字符 |
| description   | string | 否   | 项目描述              |
| ontology_file | file   | 否   | 自定义本体论JSON文件  |

**请求示例**:

```http
POST /api/v1/projects/
Content-Type: multipart/form-data

name=事故报告分析项目
description=用于分析2024年事故报告
ontology_file=<file>
```

**成功响应** (201 Created):

```json
{
  "status": 201,
  "message": "项目创建成功",
  "data": {
    "id": 1,
    "name": "事故报告分析项目",
    "description": "用于分析2024年事故报告",
    "ontology_path": "ontology/1.json",
    "created_by": {
      "id": 1,
      "username": "user123"
    },
    "created_at": "2026-01-20T10:00:00Z",
    "updated_at": "2026-01-20T10:00:00Z"
  }
}
```

**错误响应** (400 Bad Request):

```json
{
  "status": 400,
  "message": "项目名称不能为空",
  "data": null
}
```

#### 2.2.2 查询项目列表

**端点**: `GET /api/v1/projects/`

**请求头**:

```
X-User-ID: user123
```

**查询参数**: 无（未来可扩展分页、搜索）

**成功响应** (200 OK):

```json
{
  "status": 200,
  "message": "",
  "data": [
    {
      "id": 1,
      "name": "项目A",
      "description": "描述A",
      "ontology_path": "ontology/1.json",
      "created_at": "2026-01-20T10:00:00Z",
      "file_count": 5
    },
    {
      "id": 2,
      "name": "项目B",
      "description": null,
      "ontology_path": "ontology/ontology_v2.json",
      "created_at": "2026-01-19T15:30:00Z",
      "file_count": 3
    }
  ]
}
```

#### 2.2.3 查询项目详情

**端点**: `GET /api/v1/projects/{id}/`

**路径参数**:

- `id`: 项目ID

**成功响应** (200 OK):

```json
{
  "status": 200,
  "message": "",
  "data": {
    "id": 1,
    "name": "事故报告分析项目",
    "description": "用于分析2024年事故报告",
    "ontology_path": "ontology/1.json",
    "created_by": {
      "id": 1,
      "username": "user123"
    },
    "created_at": "2026-01-20T10:00:00Z",
    "updated_at": "2026-01-20T10:00:00Z",
    "file_count": 5,
    "completed_count": 3,
    "failed_count": 1,
    "processing_count": 1
  }
}
```

**错误响应** (404 Not Found):

```json
{
  "status": 404,
  "message": "项目不存在或已删除",
  "data": null
}
```

#### 2.2.4 删除项目

**端点**: `DELETE /api/v1/projects/{id}/`

**路径参数**:

- `id`: 项目ID

**成功响应** (200 OK):

```json
{
  "status": 200,
  "message": "项目已删除",
  "data": null
}
```

**说明**: 软删除，设置is_deleted=True，不删除物理文件

---

### 2.3 文件管理API

#### 2.3.1 上传PDF文件

**端点**: `POST /api/v1/projects/{project_id}/files/`

**请求头**:

```
Content-Type: multipart/form-data
X-User-ID: user123
```

**路径参数**:

- `project_id`: 项目ID

**请求参数**:

| 参数名   | 类型 | 必需 | 说明              |
| -------- | ---- | ---- | ----------------- |
| pdf_file | file | 是   | PDF文件，最大50MB |

**请求示例**:

```http
POST /api/v1/projects/1/files/
Content-Type: multipart/form-data

pdf_file=<file.pdf>
```

**成功响应** (201 Created):

```json
{
  "status": 201,
  "message": "文件上传成功，开始处理",
  "data": {
    "id": 10,
    "project_id": 1,
    "filename": "uuid123_报告.pdf",
    "original_name": "报告.pdf",
    "pdf_path": "pdf/1/uuid123_报告.pdf",
    "status": "pending",
    "task_id": "celery-task-uuid-456",
    "uploaded_at": "2026-01-20T10:30:00Z"
  }
}
```

**错误响应** (400 Bad Request):

```json
{
  "status": 400,
  "message": "文件大小超过50MB限制",
  "data": null
}
```

**错误响应** (400 Bad Request):

```json
{
  "status": 400,
  "message": "仅支持PDF格式文件",
  "data": null
}
```

#### 2.3.2 查询文件列表（分页）

**端点**: `GET /api/v1/projects/{project_id}/files/`

**路径参数**:

- `project_id`: 项目ID

**查询参数**:

| 参数名    | 类型    | 必需 | 默认值 | 说明              |
| --------- | ------- | ---- | ------ | ----------------- |
| page      | integer | 否   | 1      | 页码，从1开始     |
| page_size | integer | 否   | 10     | 每页数量，最大100 |

**请求示例**:

```http
GET /api/v1/projects/1/files/?page=1&page_size=10
```

**成功响应** (200 OK):

```json
{
  "status": 200,
  "message": "",
  "data": {
    "count": 25,
    "page": 1,
    "page_size": 10,
    "results": [
      {
        "id": 25,
        "filename": "uuid789_最新报告.pdf",
        "original_name": "最新报告.pdf",
        "status": "completed",
        "uploaded_at": "2026-01-20T12:00:00Z",
        "processed_at": "2026-01-20T12:08:30Z"
      },
      {
        "id": 24,
        "filename": "uuid456_分析文档.pdf",
        "original_name": "分析文档.pdf",
        "status": "processing",
        "uploaded_at": "2026-01-20T11:45:00Z",
        "processed_at": null
      },
      {
        "id": 23,
        "filename": "uuid123_测试.pdf",
        "original_name": "测试.pdf",
        "status": "failed",
        "uploaded_at": "2026-01-20T11:30:00Z",
        "processed_at": "2026-01-20T11:35:00Z"
      }
    ]
  }
}
```

#### 2.3.3 查询文件详情

**端点**: `GET /api/v1/files/{file_id}/`

**路径参数**:

- `file_id`: 文件ID

**成功响应** (200 OK):

```json
{
  "status": 200,
  "message": "",
  "data": {
    "id": 10,
    "project": {
      "id": 1,
      "name": "事故报告分析项目"
    },
    "filename": "uuid123_报告.pdf",
    "original_name": "报告.pdf",
    "pdf_path": "pdf/1/uuid123_报告.pdf",
    "status": "completed",
    "mineru_output_path": "mineru/1/uuid123_报告/",
    "extraction_output_path": "extraction/1/uuid123_报告/",
    "error_message": null,
    "task_id": "celery-task-uuid-456",
    "uploaded_at": "2026-01-20T10:30:00Z",
    "processed_at": "2026-01-20T10:38:20Z"
  }
}
```

**错误响应** (404 Not Found):

```json
{
  "status": 404,
  "message": "文件不存在",
  "data": null
}
```

#### 2.3.4 查询文件提取内容

**端点**: `GET /api/v1/files/{file_id}/content/`

**路径参数**:

- `file_id`: 文件ID

**成功响应** (200 OK):

```json
{
  "status": 200,
  "message": "",
  "data": {
    "file_id": 10,
    "status": "completed",
    "markdown_text": "# 事故报告\n\n## 基本情况\n...",
    "ontology_json": {
      "_metadata": {
        "document_name": "报告.pdf",
        "processed_at": "2026-01-20T10:38:00Z",
        "ontology_version": "v2.0"
      },
      "报告元信息": {
        "报告编号": {
          "value": "REPORT-2024-001",
          "reference": "第1页，第2段"
        },
        "报告日期": {
          "value": "2024-05-14",
          "reference": "第1页，标题"
        }
      },
      "事故基本情况": {
        // ... 本体论结构化数据
      }
    }
  }
}
```

**错误响应** (400 Bad Request - 文件未处理完成):

```json
{
  "status": 400,
  "message": "文件尚未处理完成，当前状态: processing",
  "data": {
    "file_id": 10,
    "status": "processing"
  }
}
```

**错误响应** (400 Bad Request - 文件处理失败):

```json
{
  "status": 400,
  "message": "文件处理失败",
  "data": {
    "file_id": 10,
    "status": "failed",
    "error_message": "MinerU API超时，PDF格式不支持"
  }
}
```

---

## 3. 核心模块详细设计

### 3.1 认证模块 (text_extraction/authentication.py)

#### 3.1.1 功能描述

- 从HTTP Header读取X-User-ID
- 验证user_id有效性
- 自动创建不存在的Django User（username=user_id）
- 设置request.user为Django User实例

#### 3.1.2 代码骨架

```python
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
from django.contrib.auth.models import User

class HeaderAuthentication(BaseAuthentication):
    """
    基于Nginx Header的用户认证
  
    从X-User-ID header获取用户标识，自动创建Django User记录
    """
  
    def authenticate(self, request):
        user_id = request.META.get('HTTP_X_USER_ID')
  
        if not user_id:
            raise AuthenticationFailed('缺少X-User-ID header')
  
        # 验证user_id格式（可选）
        if not self._is_valid_user_id(user_id):
            raise AuthenticationFailed('无效的X-User-ID格式')
  
        # 获取或创建Django User（username=user_id）
        user, created = User.objects.get_or_create(
            username=user_id,
            defaults={
                'is_active': True,
            }
        )
  
        # 如果是新创建的用户，设置不可用密码
        if created:
            user.set_unusable_password()
            user.save(update_fields=['password'])
  
        return (user, None)
  
    def _is_valid_user_id(self, user_id):
        """验证user_id格式"""
        # Django username最大150字符
        return len(user_id) > 0 and len(user_id) <= 150
```

### 3.2 统一响应格式模块 (text_extraction/renderers.py)

#### 3.2.1 功能描述

- 包装所有API响应为统一格式
- 处理成功响应和错误响应
- 保留DRF框架原生异常响应

#### 3.2.2 代码骨架

```python
from rest_framework.renderers import JSONRenderer

class StandardJSONRenderer(JSONRenderer):
    """
    统一响应格式渲染器
  
    包装所有响应为: {"status": 200, "message": "", "data": ...}
    """
  
    def render(self, data, accepted_media_type=None, renderer_context=None):
        response = renderer_context['response']
  
        # 如果已经是标准格式，直接返回
        if isinstance(data, dict) and 'status' in data:
            return super().render(data, accepted_media_type, renderer_context)
  
        # 包装为标准格式
        standard_data = {
            'status': response.status_code,
            'message': self._get_message(data, response.status_code),
            'data': data if response.status_code < 400 else None
        }
  
        return super().render(standard_data, accepted_media_type, renderer_context)
  
    def _get_message(self, data, status_code):
        """提取错误消息"""
        if status_code >= 400:
            if isinstance(data, dict):
                # 提取第一个错误消息
                for key, value in data.items():
                    if isinstance(value, list):
                        return f"{key}: {value[0]}"
                    return str(value)
            elif isinstance(data, list):
                return str(data[0])
            elif isinstance(data, str):
                return data
        return ""
```

---

### 3.4 MinerU集成服务 (text_extraction/services/mineru_service.py)

#### 3.4.1 功能描述

- 调用MinerU Web API进行PDF转Markdown
- 处理HTTP请求超时和重试
- 解析MinerU返回结果

#### 3.4.2 代码骨架

```python
import requests
import logging
from django.conf import settings

logger = logging.getLogger(__name__)

class MinerUService:
    """MinerU Web服务集成"""
  
    def __init__(self):
        self.base_url = settings.MINERU_API_URL
        self.timeout = settings.MINERU_TIMEOUT  # 300秒
  
    def extract_pdf(self, pdf_path, output_dir):
        """
        调用MinerU API提取PDF内容
  
        Args:
            pdf_path: PDF文件绝对路径
            output_dir: 输出目录绝对路径
  
        Returns:
            dict: {
                'markdown_path': str,
                'images_dir': str,
                'metadata_path': str
            }
  
        Raises:
            MinerUAPIError: API调用失败
        """
        try:
            logger.info(f"调用MinerU API: {pdf_path}")
      
            # 根据MinerU官方API文档构造请求
            # TODO: 查阅MinerU官方文档，确定准确的API接口
            response = requests.post(
                f"{self.base_url}/api/convert",
                json={
                    'pdf_path': pdf_path,
                    'output_dir': output_dir,
                    'mode': 'auto'  # auto/ocr/txt
                },
                timeout=self.timeout
            )
      
            response.raise_for_status()
            result = response.json()
      
            logger.info(f"MinerU处理成功: {result}")
      
            return {
                'markdown_path': result.get('markdown_file'),
                'images_dir': result.get('images_dir'),
                'metadata_path': result.get('metadata_file')
            }
      
        except requests.Timeout:
            logger.error(f"MinerU API超时: {pdf_path}")
            raise MinerUAPIError("PDF处理超时")
        except requests.RequestException as e:
            logger.error(f"MinerU API错误: {e}")
            raise MinerUAPIError(f"PDF处理失败: {str(e)}")

class MinerUAPIError(Exception):
    """MinerU API异常"""
    pass
```

---

### 3.5 本体论提取服务 (apps/files/services/ontology_service.py)

#### 3.5.1 功能描述

- 封装Step5的OntologyAgent
- 提供简洁的调用接口
- 处理提取异常

#### 3.5.2 代码骨架

```python
import logging
from pathlib import Path
from Step5_ontology_agent_v2 import OntologyAgent

logger = logging.getLogger(__name__)

class OntologyService:
    """本体论信息提取服务"""
  
    @staticmethod
    def extract(markdown_path, ontology_path, output_dir):
        """
        提取本体论结构化信息
  
        Args:
            markdown_path: Markdown文件路径
            ontology_path: 本体论JSON文件路径
            output_dir: 输出目录路径
  
        Returns:
            dict: {
                'ontology_json_path': str,
                'memory_json_path': str
            }
  
        Raises:
            OntologyExtractionError: 提取失败
        """
        try:
            logger.info(f"开始本体论提取: {markdown_path}")
      
            # 创建OntologyAgent实例
            agent = OntologyAgent(ontology_path=ontology_path)
      
            # 执行处理
            result = agent.process_document(
                md_file_path=str(markdown_path),
                output_dir=str(output_dir)
            )
      
            if not result['success']:
                raise OntologyExtractionError(result.get('error', '未知错误'))
      
            logger.info(f"本体论提取成功: {result['output']}")
      
            # 构造返回路径
            md_stem = Path(markdown_path).stem
            return {
                'ontology_json_path': f"{output_dir}/{md_stem}_ontology.json",
                'memory_json_path': f"{output_dir}/{md_stem}_memory.json"
            }
      
        except Exception as e:
            logger.error(f"本体论提取失败: {e}", exc_info=True)
            raise OntologyExtractionError(str(e))

class OntologyExtractionError(Exception):
    """本体论提取异常"""
    pass
```

---

### 3.6 Celery任务模块 (apps/files/tasks.py)

#### 3.6.1 功能描述

- 异步处理PDF文件
- 调用MinerU和Step5服务
- 更新数据库状态

#### 3.6.2 代码骨架

```python
from celery import shared_task
from django.conf import settings
from django.utils import timezone
from apps.files.models import File
from apps.files.services.mineru_service import MinerUService, MinerUAPIError
from apps.files.services.ontology_service import OntologyService, OntologyExtractionError
import logging
import os

logger = logging.getLogger(__name__)

@shared_task(
    bind=True,
    max_retries=0,  # 不自动重试
    time_limit=1800,  # 30分钟硬超时
    soft_time_limit=1800
)
def process_pdf_task(self, file_id):
    """
    PDF处理任务
  
    流程:
    1. 更新状态为processing
    2. 调用MinerU提取文本
    3. 调用Step5提取本体论
    4. 更新状态为completed
  
    Args:
        file_id: File模型ID
    """
    logger.info(f"开始处理PDF任务: file_id={file_id}")
  
    try:
        # 1. 获取文件记录
        file_obj = File.objects.get(id=file_id)
        project = file_obj.project
  
        # 2. 更新状态为processing
        file_obj.status = 'processing'
        file_obj.save(update_fields=['status'])
  
        # 3. 调用MinerU提取
        logger.info(f"调用MinerU提取: {file_obj.pdf_path}")
  
        pdf_abs_path = os.path.join(settings.MEDIA_ROOT, file_obj.pdf_path)
        mineru_output_dir = os.path.join(
            settings.MEDIA_ROOT,
            f"mineru/{project.id}/{Path(file_obj.filename).stem}"
        )
        os.makedirs(mineru_output_dir, exist_ok=True)
  
        mineru_service = MinerUService()
        mineru_result = mineru_service.extract_pdf(
            pdf_path=pdf_abs_path,
            output_dir=mineru_output_dir
        )
  
        # 更新mineru输出路径
        file_obj.mineru_output_path = mineru_result['markdown_path'].replace(
            settings.MEDIA_ROOT + '/', ''
        )
        file_obj.save(update_fields=['mineru_output_path'])
  
        # 4. 调用Step5提取本体论
        logger.info(f"调用Step5提取本体论")
  
        ontology_abs_path = os.path.join(settings.MEDIA_ROOT, project.ontology_path)
        extraction_output_dir = os.path.join(
            settings.MEDIA_ROOT,
            f"extraction/{project.id}/{Path(file_obj.filename).stem}"
        )
        os.makedirs(extraction_output_dir, exist_ok=True)
  
        ontology_service = OntologyService()
        extraction_result = ontology_service.extract(
            markdown_path=mineru_result['markdown_path'],
            ontology_path=ontology_abs_path,
            output_dir=extraction_output_dir
        )
  
        # 更新extraction输出路径
        file_obj.extraction_output_path = extraction_result['ontology_json_path'].replace(
            settings.MEDIA_ROOT + '/', ''
        )
  
        # 5. 标记为completed
        file_obj.status = 'completed'
        file_obj.processed_at = timezone.now()
        file_obj.save(update_fields=[
            'extraction_output_path',
            'status',
            'processed_at'
        ])
  
        logger.info(f"PDF处理完成: file_id={file_id}")
        return {'success': True, 'file_id': file_id}
  
    except File.DoesNotExist:
        logger.error(f"文件不存在: file_id={file_id}")
        return {'success': False, 'error': '文件不存在'}
  
    except (MinerUAPIError, OntologyExtractionError) as e:
        # 处理失败，标记为failed
        logger.error(f"PDF处理失败: {e}", exc_info=True)
  
        try:
            file_obj = File.objects.get(id=file_id)
            file_obj.status = 'failed'
            file_obj.error_message = str(e)
            file_obj.processed_at = timezone.now()
            file_obj.save(update_fields=['status', 'error_message', 'processed_at'])
        except Exception as update_error:
            logger.error(f"更新状态失败: {update_error}")
  
        return {'success': False, 'error': str(e)}
  
    except Exception as e:
        # 未知异常
        logger.error(f"未知异常: {e}", exc_info=True)
  
        try:
            file_obj = File.objects.get(id=file_id)
            file_obj.status = 'failed'
            file_obj.error_message = f"系统错误: {str(e)}"
            file_obj.processed_at = timezone.now()
            file_obj.save(update_fields=['status', 'error_message', 'processed_at'])
        except Exception as update_error:
            logger.error(f"更新状态失败: {update_error}")
  
        return {'success': False, 'error': str(e)}
```

---

## 4. 业务流程详细设计

### 4.1 文件上传与处理流程

```
用户上传PDF
     │
     ▼
[FileUploadView]
     │
     ├─ 1. 验证X-User-ID header (HeaderAuthentication)
     │     ├─ 成功: 获取或创建User
     │     └─ 失败: 返回401
     │
     ├─ 2. 验证项目存在 (get project)
     │     ├─ 存在: 继续
     │     └─ 不存在: 返回404
     │
     ├─ 3. 验证文件 (FileUploadSerializer)
     │     ├─ 检查文件类型 (PDF)
     │     ├─ 检查文件大小 (<= 50MB)
     │     └─ 失败: 返回400
     │
     ├─ 4. 保存文件到磁盘
     │     ├─ 生成UUID
     │     ├─ 构造文件名: {uuid}_{original_name}
     │     └─ 保存到: media/pdf/{project_id}/{filename}
     │
     ├─ 5. 创建File记录
     │     ├─ project = project_obj
     │     ├─ filename = uuid_original_name
     │     ├─ original_name = original_name
     │     ├─ pdf_path = "pdf/{project_id}/{filename}"
     │     ├─ status = 'pending'
     │     └─ created_by = request.user
     │
     ├─ 6. 触发Celery任务
     │     ├─ task = process_pdf_task.delay(file_obj.id)
     │     ├─ file_obj.task_id = task.id
     │     └─ file_obj.save()
     │
     └─ 7. 返回响应
           └─ {"status": 201, "data": {...}}

                    │
                    ▼
            [RabbitMQ队列]
                    │
                    ▼
        [Celery Worker获取任务]
                    │
                    ▼
        [process_pdf_task执行]
                    │
                    ├─ 1. 更新status = 'processing'
                    │
                    ├─ 2. 调用MinerU API
                    │     ├─ POST {base_url}/api/convert
                    │     ├─ 参数: pdf_path, output_dir
                    │     ├─ 超时: 300秒
                    │     ├─ 成功: 获取markdown_path
                    │     └─ 失败: 抛MinerUAPIError
                    │
                    ├─ 3. 更新mineru_output_path
                    │
                    ├─ 4. 调用Step5 OntologyAgent
                    │     ├─ agent = OntologyAgent(ontology_path)
                    │     ├─ agent.process_document(md_path, output_dir)
                    │     ├─ 成功: 获取ontology_json_path
                    │     └─ 失败: 抛OntologyExtractionError
                    │
                    ├─ 5. 更新extraction_output_path
                    │
                    ├─ 6. 更新status = 'completed'
                    │     └─ processed_at = now()
                    │
                    └─ 异常处理
                          ├─ MinerUAPIError / OntologyExtractionError
                          │     ├─ status = 'failed'
                          │     ├─ error_message = str(e)
                          │     └─ processed_at = now()
                          │
                          └─ 其他Exception
                                ├─ status = 'failed'
                                ├─ error_message = "系统错误: ..."
                                └─ processed_at = now()
```

### 4.2 项目创建流程

```
用户创建项目
     │
     ▼
[ProjectViewSet.create]
     │
     ├─ 1. 验证X-User-ID header
     │
     ├─ 2. 验证请求数据 (ProjectCreateSerializer)
     │     ├─ name: required
     │     ├─ description: optional
     │     └─ ontology_file: optional
     │
     ├─ 3. 创建Project对象
     │     ├─ name = validated_data['name']
     │     ├─ description = validated_data.get('description')
     │     ├─ created_by = request.user
     │     └─ save() -> 获取project.id
     │
     ├─ 4. 处理本体论文件
     │     │
     │     ├─ 是否上传ontology_file?
     │     │
     │     ├─ 是 ─────────────────────────┐
     │     │                              │
     │     │                              ▼
     │     │                    保存上传文件
     │     │                    ├─ 路径: media/ontology/{project_id}.json
     │     │                    └─ project.ontology_path = "ontology/{id}.json"
     │     │
     │     └─ 否 ─────────────────────────┐
     │                                    │
     │                                    ▼
     │                          使用默认本体论
     │                          ├─ 复制 ontology_v2.json
     │                          ├─ 到 media/ontology/{project_id}.json
     │                          └─ project.ontology_path = "ontology/{id}.json"
     │
     ├─ 5. 保存project更新
     │
     └─ 6. 返回响应
           └─ {"status": 201, "data": {...}}
```

---

## 5. 文件存储设计

### 5.1 目录结构

```
media/                              # MEDIA_ROOT
├── pdf/                            # 原始PDF文件
│   ├── 1/                          # 项目ID=1
│   │   ├── uuid1_报告A.pdf
│   │   ├── uuid2_报告B.pdf
│   │   └── ...
│   ├── 2/                          # 项目ID=2
│   │   └── ...
│   └── ...
│
├── mineru/                         # MinerU输出
│   ├── 1/                          # 项目ID=1
│   │   ├── uuid1_报告A/
│   │   │   ├── uuid1_报告A.md      # Markdown文本
│   │   │   ├── uuid1_报告A_model.json
│   │   │   ├── uuid1_报告A_middle.json
│   │   │   ├── uuid1_报告A_content_list.json
│   │   │   └── images/             # 提取的图片
│   │   │       ├── img_001.png
│   │   │       └── ...
│   │   └── ...
│   └── ...
│
├── extraction/                     # 本体论提取结果
│   ├── 1/                          # 项目ID=1
│   │   ├── uuid1_报告A/
│   │   │   ├── uuid1_报告A_ontology.json    # 本体论JSON
│   │   │   └── uuid1_报告A_memory.json      # 处理记忆
│   │   └── ...
│   └── ...
│
└── ontology/                       # 项目本体论文件
    ├── ontology_v2.json            # 默认本体论
    ├── 1.json                      # 项目1的自定义本体论
    ├── 2.json                      # 项目2的自定义本体论
    └── ...
```

### 5.2 路径管理策略

#### 5.2.1 相对路径存储

- 数据库中所有路径字段存储相对于 `MEDIA_ROOT`的相对路径
- 示例: `pdf/1/uuid123_报告.pdf`
- 读取时拼接: `os.path.join(settings.MEDIA_ROOT, file.pdf_path)`

#### 5.2.2 文件命名规则

- **PDF文件**: `{uuid}_{original_name}.pdf`
- **MinerU目录**: `{uuid}_{stem}/`
- **本体论目录**: `{uuid}_{stem}/`

#### 5.2.3 UUID生成

```python
import uuid
from pathlib import Path

def generate_unique_filename(original_filename):
    """
    生成唯一文件名
  
    Args:
        original_filename: 原始文件名
  
    Returns:
        str: uuid_原始文件名
    """
    file_uuid = uuid.uuid4().hex[:12]
    return f"{file_uuid}_{original_filename}"
```

---

## 6. Celery配置详细设计

### 6.1 Celery初始化 (backend/celery.py)

```python
import os
from celery import Celery

# 设置Django settings模块
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings.development')

app = Celery('backend')

# 从Django settings加载配置
app.config_from_object('django.conf:settings', namespace='CELERY')

# 自动发现任务
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

### 6.2 Django Settings配置

```python
# backend/settings/base.py

# Celery配置
CELERY_BROKER_URL = os.environ.get('CELERY_BROKER_URL', 'amqp://guest:guest@localhost:5672//')
CELERY_RESULT_BACKEND = os.environ.get('CELERY_RESULT_BACKEND', 'redis://localhost:6379/0')

# 任务配置
CELERY_TASK_ACKS_LATE = True              # 任务执行后才确认
CELERYD_PREFETCH_MULTIPLIER = 1           # 单个Worker只预取1个任务（保证串行）
CELERY_TASK_TIME_LIMIT = 1800             # 30分钟硬超时
CELERY_TASK_SOFT_TIME_LIMIT = 1800        # 30分钟软超时

# 结果配置
CELERY_RESULT_EXPIRES = 604800            # 结果保留7天
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TASK_SERIALIZER = 'json'
CELERY_ACCEPT_CONTENT = ['json']

# 日志配置
CELERY_WORKER_LOG_FORMAT = '[%(asctime)s: %(levelname)s/%(processName)s] %(message)s'
CELERY_WORKER_TASK_LOG_FORMAT = '[%(asctime)s: %(levelname)s/%(processName)s][%(task_name)s(%(task_id)s)] %(message)s'
```

### 6.3 Worker启动命令

```bash
# 开发环境
celery -A backend worker -c 1 -l info

# 生产环境（多Worker）
celery -A backend worker -c 1 -l info --hostname=worker1@%h
celery -A backend worker -c 1 -l info --hostname=worker2@%h
```

---

## 7. OpenAPI文档配置

### 7.1 drf-spectacular配置

```python
# backend/settings/base.py

INSTALLED_APPS = [
    ...
    'drf_spectacular',
]

REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}

SPECTACULAR_SETTINGS = {
    'TITLE': 'PDF文本提取API',
    'DESCRIPTION': 'PDF文档智能处理与本体论信息提取服务',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
    'COMPONENT_SPLIT_REQUEST': True,
    'SCHEMA_PATH_PREFIX': '/api/v1/',
}
```

### 7.2 URL配置

```python
# backend/urls.py
from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView
from django.urls import path, include

urlpatterns = [
    # API路由
    path('api/v1/', include([
        path('projects/', include('apps.projects.urls')),
        path('files/', include('apps.files.urls')),
    ])),
  
    # OpenAPI Schema
    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
  
    # Swagger UI
    path('api/docs/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'),
]
```

### 7.3 ViewSet文档注解

```python
from drf_spectacular.utils import extend_schema, OpenApiParameter
from rest_framework import viewsets

class ProjectViewSet(viewsets.ModelViewSet):
    """项目管理API"""
  
    @extend_schema(
        summary="创建项目",
        description="创建新项目，可选上传自定义本体论JSON文件",
        request=ProjectCreateSerializer,
        responses={201: ProjectSerializer}
    )
    def create(self, request, *args, **kwargs):
        ...
  
    @extend_schema(
        summary="项目列表",
        description="查询所有未删除的项目列表",
        responses={200: ProjectSerializer(many=True)}
    )
    def list(self, request, *args, **kwargs):
        ...
```

---

**文档结束**
